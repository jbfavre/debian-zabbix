Description: Support of trends.get method for API
 Add support for trends in Zabbix API same way as for history
Author: D.Spindel Ljungmark 
Origin: other, https://support.zabbix.com/browse/ZBXNEXT-1193
Bug: https://support.zabbix.com/browse/ZBXNEXT-1193
Reviewed-by: Jean Baptiste Favre <debian@jbfavre.org>
Last-Update: 2015-06-27
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
Index: zabbix/frontends/php/include/classes/api/API.php
===================================================================
--- zabbix.orig/frontends/php/include/classes/api/API.php	2015-06-27 18:16:07.545304383 +0200
+++ zabbix/frontends/php/include/classes/api/API.php	2015-06-27 18:17:07.009485029 +0200
@@ -332,6 +332,13 @@
 		return self::getApi('templatescreenitem');
 	}
 
+        /**
+         * @return CTrend
+         */
+        public static function Trend() {
+                return self::getApi('trend');
+        }
+
 	/**
 	 * @return CTrigger
 	 */
Index: zabbix/frontends/php/include/classes/api/CApiServiceFactory.php
===================================================================
--- zabbix.orig/frontends/php/include/classes/api/CApiServiceFactory.php	2015-06-27 18:16:07.545304383 +0200
+++ zabbix/frontends/php/include/classes/api/CApiServiceFactory.php	2015-06-27 18:17:07.009485029 +0200
@@ -61,6 +61,7 @@
 			'template' => 'CTemplate',
 			'templatescreen' => 'CTemplateScreen',
 			'templatescreenitem' => 'CTemplateScreenItem',
+			'trend' => 'CTrend',
 			'trigger' => 'CTrigger',
 			'triggerprototype' => 'CTriggerPrototype',
 			'user' => 'CUser',
Index: zabbix/frontends/php/include/classes/api/services/CTrend.php
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ zabbix/frontends/php/include/classes/api/services/CTrend.php	2015-06-27 18:17:07.009485029 +0200
@@ -0,0 +1,219 @@
+<?php
+/*
+** Zabbix
+** Copyright (C) 2001-2014 Zabbix SIA
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+**/
+
+
+/**
+ * Class containing methods for operations with histories.
+ *
+ * @package API
+ */
+class CTrend extends CApiService {
+
+	protected $tableName = 'trends';
+	protected $tableAlias = 'h';
+	protected $sortColumns = array('itemid', 'clock');
+
+	public function __construct() {
+		// considering the quirky nature of the trend API,
+		// the parent::__construct() method should not be called.
+	}
+
+	/**
+	 * Get trend data.
+	 *
+	 * @param array $options
+	 * @param array $options['itemids']
+	 * @param boolean $options['editable']
+	 * @param string $options['pattern']
+	 * @param int $options['limit']
+	 * @param string $options['order']
+	 *
+	 * @return array|int item data as array or false if error
+	 */
+	public function get($options = array()) {
+		$result = array();
+
+		$sqlParts = array(
+			'select'	=> array('trend' => 'h.itemid'),
+			'from'		=> array(),
+			'where'		=> array(),
+			'group'		=> array(),
+			'order'		=> array(),
+			'limit'		=> null
+		);
+
+		$defOptions = array(
+			'trend'					=> ITEM_VALUE_TYPE_UINT64,
+			'hostids'					=> null,
+			'itemids'					=> null,
+			'editable'					=> null,
+			'nopermissions'				=> null,
+			// filter
+			'filter'					=> null,
+			'search'					=> null,
+			'searchByAny'				=> null,
+			'startSearch'				=> null,
+			'excludeSearch'				=> null,
+			'searchWildcardsEnabled'	=> null,
+			'time_from'					=> null,
+			'time_till'					=> null,
+			// output
+			'output'					=> API_OUTPUT_EXTEND,
+			'countOutput'				=> null,
+			'groupCount'				=> null,
+			'preservekeys'				=> null,
+			'sortfield'					=> '',
+			'sortorder'					=> '',
+			'limit'						=> null
+		);
+
+		$options = zbx_array_merge($defOptions, $options);
+
+		$tables = array(
+			ITEM_VALUE_TYPE_FLOAT => 'trends',
+			ITEM_VALUE_TYPE_UINT64 => 'trends_uint'
+		);
+
+		if (!$tableName = $tables[$options['trend']]) {
+			$tableName = 'trends_uint';
+		}
+		$sqlParts['from']['trend'] = $tableName.' h';
+
+		// editable + PERMISSION CHECK
+		if (USER_TYPE_SUPER_ADMIN == self::$userData['type'] || $options['nopermissions']) {
+		}
+		else {
+			$items = API::Item()->get(array(
+				'itemids' => ($options['itemids'] === null) ? null : $options['itemids'],
+				'output' => array('itemid'),
+				'editable' => $options['editable'],
+				'preservekeys' => true,
+				'webitems' => true
+			));
+			$options['itemids'] = array_keys($items);
+		}
+
+		// itemids
+		if (!is_null($options['itemids'])) {
+			zbx_value2array($options['itemids']);
+			$sqlParts['where']['itemid'] = dbConditionInt('h.itemid', $options['itemids']);
+		}
+
+		// hostids
+		if (!is_null($options['hostids'])) {
+			zbx_value2array($options['hostids']);
+
+			$sqlParts['from']['items'] = 'items i';
+			$sqlParts['where']['i'] = dbConditionInt('i.hostid', $options['hostids']);
+			$sqlParts['where']['hi'] = 'h.itemid=i.itemid';
+		}
+
+		// time_from
+		if (!is_null($options['time_from'])) {
+			$sqlParts['where']['clock_from'] = 'h.clock>='.zbx_dbstr($options['time_from']);
+		}
+
+		// time_till
+		if (!is_null($options['time_till'])) {
+			$sqlParts['where']['clock_till'] = 'h.clock<='.zbx_dbstr($options['time_till']);
+		}
+
+		// filter
+		if (is_array($options['filter'])) {
+			$this->dbFilter($sqlParts['from']['trend'], $options, $sqlParts);
+		}
+
+		// search
+		if (is_array($options['search'])) {
+			zbx_db_search($sqlParts['from']['trend'], $options, $sqlParts);
+		}
+
+		// output
+		if ($options['output'] == API_OUTPUT_EXTEND) {
+			unset($sqlParts['select']['clock']);
+			$sqlParts['select']['trend'] = 'h.*';
+		}
+
+		// countOutput
+		if (!is_null($options['countOutput'])) {
+			$options['sortfield'] = '';
+			$sqlParts['select'] = array('count(DISTINCT h.hostid) as rowscount');
+
+			// groupCount
+			if (!is_null($options['groupCount'])) {
+				foreach ($sqlParts['group'] as $key => $fields) {
+					$sqlParts['select'][$key] = $fields;
+				}
+			}
+		}
+
+		// sorting
+		$sqlParts = $this->applyQuerySortOptions($tableName, $this->tableAlias(), $options, $sqlParts);
+
+		// limit
+		if (zbx_ctype_digit($options['limit']) && $options['limit']) {
+			$sqlParts['limit'] = $options['limit'];
+		}
+
+		$sqlParts['select'] = array_unique($sqlParts['select']);
+		$sqlParts['from'] = array_unique($sqlParts['from']);
+		$sqlParts['where'] = array_unique($sqlParts['where']);
+		$sqlParts['order'] = array_unique($sqlParts['order']);
+
+		$sqlSelect = '';
+		$sqlFrom = '';
+		$sqlOrder = '';
+		if (!empty($sqlParts['select'])) {
+			$sqlSelect .= implode(',', $sqlParts['select']);
+		}
+		if (!empty($sqlParts['from'])) {
+			$sqlFrom .= implode(',', $sqlParts['from']);
+		}
+		$sqlWhere = !empty($sqlParts['where']) ? ' WHERE '.implode(' AND ', $sqlParts['where']) : '';
+		if (!empty($sqlParts['order'])) {
+			$sqlOrder .= ' ORDER BY '.implode(',', $sqlParts['order']);
+		}
+		$sqlLimit = $sqlParts['limit'];
+
+		$sql = 'SELECT '.$sqlSelect.
+				' FROM '.$sqlFrom.
+				$sqlWhere.
+				$sqlOrder;
+
+		# DEBUG: Print SQL Statement to File.
+		#file_put_contents('/tmp/trends.sql', $sql);
+
+		$dbRes = DBselect($sql, $sqlLimit);
+		while ($data = DBfetch($dbRes)) {
+			if ($options['countOutput']) {
+				$result = $data;
+			}
+			else {
+				$result[] = $data;
+			}
+		}
+
+		if (is_null($options['preservekeys'])) {
+			$result = zbx_cleanHashes($result);
+		}
+		return $result;
+	}
+
+}
